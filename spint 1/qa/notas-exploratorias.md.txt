Notas de Pruebas Exploratorias – Sprint 1 – Proyecto Digital Money House

Estas notas registran las actividades y observaciones durante las sesiones de prueba exploratoria realizadas en el Sprint 1. El objetivo de la exploración fue descubrir comportamientos no previstos y obtener un entendimiento profundo del flujo de autenticación de la billetera digital.

1 Sesión 1 – Tour de Registro y validaciones de campos
1.1 Objetivo

Evaluar la robustez del endpoint POST /api/users frente a entradas diversas y verificar que las validaciones del frontend se transmitan al backend.

1.2 Ruta seguida

Navegué a la página de registro y completé datos válidos. La cuenta se creó con éxito y fui redirigido a la vista de confirmación. Se observó que la contraseña no se devuelve en la respuesta (correcto). Pendiente revisar si el backend retorna HTTP 201 o 200.

Ejecuté un registro con el mismo email que el usuario recién creado. El backend respondió con un mensaje Email already registered (código 409). Se confirma que existe la validación de unicidad.

Probé ingresar un DNI ya existente con un email nuevo. La API devolvió un mensaje de error similar al caso anterior. Nota: no se encuentra en la documentación si el DNI debe ser único; se infiere que sí.

Ingresé valores vacíos en uno o más campos y observé que el frontend muestra mensajes de error antes de enviar la solicitud. Sin embargo, manipulando el HTML mediante las herramientas de desarrollo del navegador logré enviar un email con formato incorrecto (usuario@) y el backend aceptó el registro. Se reportó el defecto DEF‑002 al equipo: la API no valida el formato de email.

1.3 Observaciones

Se confirma que el frontend realiza validaciones de longitud y presencia, pero el backend debería replicarlas para evitar registros inválidos.

El campo teléfono parece opcional: la API permite null sin error. Esto debe aclararse en los requisitos.

No se encontró un mecanismo de verificación por correo; la cuenta queda activada inmediatamente.

2 Sesión 2 – Tour de Login y manejo de sesiones
2.1 Objetivo

Probar distintos escenarios de autenticación y evaluar la gestión de tokens.

2.2 Ruta seguida

Intenté iniciar sesión con el usuario creado previamente y la contraseña correcta. La API respondió con un error Credenciales no válidas (HTTP 401). Se registró el defecto DEF‑003: el servicio de login no reconoce credenciales válidas.

Envié la petición con un email inexistente; la respuesta fue Unauthorized. El mensaje no distingue entre usuario inexistente o contraseña incorrecta, lo cual es adecuado por temas de seguridad.

Probé distintas contraseñas erróneas; en todos los casos el código fue 401. No se observó ningún mecanismo de bloqueo temporal tras múltiples intentos fallidos.

Una vez obtenido un token válido (accediendo vía un endpoint alternativo), invoqué GET /api/account. La respuesta incluyó los campos user_id, cvu, alias y available_amount. Inmediatamente después envié una nueva solicitud con un token manipulado, y la API respondió con 401.

2.3 Observaciones

El flujo de login está dividido en dos pasos en el frontend: captura de email y captura de contraseña. Esto facilita detectar emails inexistentes sin exponer datos sensibles.

No se verifica si el token tiene expiración; tras media hora el token siguió siendo válido. Se sugiere establecer un tiempo de expiración.

La ruta /api/account requiere el token en la cabecera Authorization. Enviar el token en una cookie no funciona.

3 Sesión 3 – Tour de Cierre de sesión
3.1 Objetivo

Validar el endpoint POST /api/logout y su efecto sobre el token de autenticación.

3.2 Ruta seguida

Con el usuario autenticado, invoqué el endpoint /api/logout enviando el token en la cabecera Authorization. La respuesta HTTP fue 200, pero al intentar acceder a /api/account con el mismo token, este seguía siendo válido y devolvía los datos del usuario. Además, en el frontend el usuario permaneció en la página de inicio con su sesión activa. Se reportó el defecto DEF‑004.

Probé enviar /api/logout sin token y con un token aleatorio. En ambos casos, el backend respondió con 200 pero no invalidó ninguna sesión. Falta una validación de autenticidad del token.

3.3 Observaciones

El logout debería invalidar el token en el servidor y eliminar la cookie en el cliente. Actualmente sólo elimina la cookie local; el token sigue siendo aceptado.

No existe un mensaje en la respuesta que indique que la sesión se cerró. Incluir un campo success podría ayudar al frontend.

4 Conclusiones generales de la exploración

El diseño de dos pasos para el login (email y contraseña en páginas separadas) mejora la experiencia de usuario pero añade complejidad a las pruebas. Es importante verificar que el estado del usuario se persista correctamente entre pasos.

Las API responden con códigos HTTP genéricos. Para los casos de error se deberían estandarizar los códigos (400 para validaciones, 401 para autenticación, 409 para duplicados, etc.) y acompañar con mensajes claros.

La falta de validaciones en el backend permite que el frontend envíe datos incorrectos si el usuario manipula el DOM. La defensa en profundidad es fundamental.

Se recomienda definir políticas de expiración y rotación de tokens, así como implementar revocación de tokens en el logout.

Estas notas servirán como referencia para enriquecer los casos de prueba de regresión y para alinear al equipo sobre las áreas que requieren mejoras inmediatas.